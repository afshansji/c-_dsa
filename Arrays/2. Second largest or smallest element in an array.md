
1. Bruteforce 
   Sort the array 
   Now there is chance we have same element twice
   declare largest = n;
   traverse from behind, check if 2nd largest is less than largest if yes declare that index as 2nd largest, if not traverse back n-2
   TC: nlogn + o(n) also chance 2nd largest doesnt exist we keep on traversing
   
   
   2. Better
      We do 2 pass 
      First pass find largest 
      2nd pass declare second_largest = -1  if array has negative numbers take INT_MIN
      now traverese and check for 2 conditions if arr [i] > s_largest && arr [i] != largest 
      finally return s_largest
      TC: first pass O(n) + O(n) = O (2n)
      

3. Optimal
   we do 1 pass,
   declare largest = arr [0], s_largest = int_min
   Now traverse check if arr [i] > largest if yes s_largest=largest, largest = arr[i]
   Traverese the array, in the end we have largest and s_largest 
   If arr[i] = largest dont do anything, if arr [i] is less than largest but greater than s_largest, s_largest = arr [i]
   TC: O(n)
   
## 1. Brute Force Approach (Sorting)

```cpp
int findSecondLargest_BruteForce(vector<int>& arr) {
    int n = arr.size();
    if (n < 2) return -1;  // Not enough elements
    
    // Sort the array in ascending order
    sort(arr.begin(), arr.end());
    
    // Start from the end (largest element)
    int largest = arr[n-1];
    
    // Traverse backwards to find second largest
    for (int i = n-2; i >= 0; i--) {
        if (arr[i] < largest) {
            return arr[i];  // Found second largest
        }
    }
    
    return -1;  // All elements are same
}
```

## 2. Better Approach (Two Pass)

```cpp
int findSecondLargest_Better(vector<int>& arr) {
    int n = arr.size();
    if (n < 2) return -1;
    
    // First pass: Find largest
    int largest = arr;
    for (int i = 1; i < n; i++) {
        if (arr[i] > largest) {
            largest = arr[i];
        }
    }
    
    // Second pass: Find second largest
    int second_largest = INT_MIN;  // or -1 if no negative numbers
    for (int i = 0; i < n; i++) {
        if (arr[i] > second_largest && arr[i] != largest) {
            second_largest = arr[i];
        }
    }
    
    // Check if second largest exists
    if (second_largest == INT_MIN) {
        return -1;  // All elements are same
    }
    
    return second_largest;
}
```

## 3. Optimal Approach (Single Pass)

```cpp
int findSecondLargest_Optimal(vector<int>& arr) {
    int n = arr.size();
    if (n < 2) return -1;
    
    int largest = arr;
    int s_largest = INT_MIN;
    
    // Single pass through array
    for (int i = 1; i < n; i++) {
        if (arr[i] > largest) {
            // New largest found
            s_largest = largest;
            largest = arr[i];
        }
        else if (arr[i] < largest && arr[i] > s_largest) {
            // Update second largest
            s_largest = arr[i];
        }
        // If arr[i] == largest, do nothing (skip duplicates)
    }
    
    // Check if second largest exists
    if (s_largest == INT_MIN) {
        return -1;  // All elements are same
    }
    
    return s_largest;
}
```

**Time Complexities:**

- Brute Force: O(n log n) for sorting + O(n) for traversal = O(n log n)
- Better: O(n) + O(n) = O(2n) â‰ˆ O(n)
- Optimal: O(n) single pass

**Space Complexities:**

- All three approaches: O(1) auxiliary space