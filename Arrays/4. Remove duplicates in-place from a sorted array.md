
array = [1, 1, 2, 2, 2, 2, 3, 3]

1. Bruteforce
   Unique -> set data structure, iterate the array put in set, as we know set contain unique elements, put each element in set
   The set after 1 iteration will have 3 elements
   Now,
   Keep index at 0 i.e at 1 move index to next 
   set doesnt have any more elements, where index stops that is size of array return that
   Set always store in acedning order i.e 1->2->3 
   TC: nlogn to insert in set + o(n)
   SC: O(n) when all are unqiue set takes all 
   
2. Optimal 
   2 pointer approach
   Since array is sorted 
   go to next and check when i is not equivalent to the prev-1
   if 1 is diff than 1 go front 
   now 2 is diff than 1 take place 
   3 is not equivalent put it infront of 2 move i when not equivalent
   keep on moving j 
   size of unique elements will be i+1
   i=0
   for j=1; j<n j++ 
   if arr [j] != arr [i]
   {
   arr[i+1] = arr [j]
   i++
   }
   
   return i+1;
   
   TC: 1 pass O(n), SC: O(1) since in same element we are traversing 
   


## Remove Duplicates from Sorted Array

### 1. Brute Force (Using Set)

```cpp
int removeDuplicates_BruteForce(vector<int>& arr) {
    int n = arr.size();
    
    // Insert all elements into set (automatically removes duplicates)
    set<int> uniqueSet;
    for (int i = 0; i < n; i++) {
        uniqueSet.insert(arr[i]);
    }
    
    // Copy back from set to array
    int index = 0;
    for (auto it : uniqueSet) {
        arr[index] = it;
        index++;
    }
    
    // Return size of unique elements
    return uniqueSet.size();
}
// TC: O(n log n) for set insertion + O(n) for copying back
// SC: O(n) for set storage
```

### 2. Optimal (Two Pointer Approach)

```cpp
int removeDuplicates_Optimal(vector<int>& arr) {
    int n = arr.size();
    if (n == 0) return 0;
    
    // i tracks position for unique elements
    int i = 0;
    
    // j traverses the array
    for (int j = 1; j < n; j++) {
        // If current element is different from previous unique
        if (arr[j] != arr[i]) {
            // Place it at next unique position
            arr[i + 1] = arr[j];
            i++;
        }
    }
    
    // Return count of unique elements
    return i + 1;
}
// TC: O(n) single pass
// SC: O(1) in-place modification
```